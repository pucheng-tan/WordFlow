{"created": "2020-11-27 19:31:45.332848", "duration": 7.791762113571167, "exitcode": 1, "root": "group2", "summary": {"passed": 23, "xpassed": 1, "failed": 1, "total": 25, "collected": 25}, "tests": [{"nodeid": "managements/test_challenge_management.py::test_get_my_challenges", "outcome": "passed", "metadata": {"id": "UT ChallengeService.1", "description": "Get the first 2 pages of challenge results and verify that they are as expected"}}, {"nodeid": "managements/test_challenge_management.py::test_get_my_challenges_last_page", "outcome": "passed", "metadata": {"id": "UT ChallengeService.2", "description": "See what happens when we make calls to paginate when there's no more data"}}, {"nodeid": "managements/test_school_management.py::test_create_school[o2lTSAI6X4yGdIZ0huB9-kUJrBZtlYJeU8ZLAFFcm4dAJVBt2]", "outcome": "passed", "metadata": ""}, {"nodeid": "managements/test_user_management.py::test_create_user[valid user-success0]", "outcome": "passed", "metadata": ""}, {"nodeid": "managements/test_user_management.py::test_create_user[valid user-success1]", "outcome": "passed", "metadata": ""}, {"nodeid": "managements/test_user_management.py::test_create_user[invalid user-error]", "outcome": "passed", "metadata": ""}, {"nodeid": "managements/test_user_management.py::test_login", "lineno": 15, "outcome": "xpassed", "keywords": ["group2", "managements/test_user_management.py", "pytestmark", "xfail", "test_login"], "setup": {"duration": 0.0003551000000001636, "outcome": "passed"}, "call": {"duration": 0.00029360000000000497, "outcome": "passed"}, "teardown": {"duration": 0.00035439999999997696, "outcome": "passed"}}, {"nodeid": "services/test_api_service.py::test_get_valid[params0-expected_references0]", "outcome": "passed", "metadata": {"id": "UT API.1", "description": "Testing various valid 'get' queries with the API: History of specific user: filter with <, ==, and in"}}, {"nodeid": "services/test_api_service.py::test_get_valid[params1-expected_references1]", "outcome": "passed", "metadata": {"id": "UT API.1", "description": "Testing various valid 'get' queries with the API: get_all for History collection: filter by the school, sort ascending the assignment ID. Test that passing in a sort which should be incompatible with the where clauses is handled gracefully"}}, {"nodeid": "services/test_api_service.py::test_get_valid[params2-expected_references2]", "outcome": "passed", "metadata": {"id": "UT API.1", "description": "Testing various valid 'get' queries with the API: filter collection by array contains specified document reference"}}, {"nodeid": "services/test_api_service.py::test_get_valid[params3-expected_references3]", "outcome": "passed", "metadata": {"id": "UT API.1", "description": "Testing various valid 'get' queries with the API: get a specific document by its path/reference"}}, {"nodeid": "services/test_api_service.py::test_get_valid[params4-expected_references4]", "outcome": "passed", "metadata": {"id": "UT API.1", "description": "Testing various valid 'get' queries with the API: get all documents in a collection with a descending sort"}}, {"nodeid": "services/test_api_service.py::test_get_invalid[params0]", "outcome": "passed", "metadata": {"id": "UT API.2", "description": "Testing 'get' queries return expected errors with invalid params: invalid limit"}}, {"nodeid": "services/test_api_service.py::test_get_invalid[params1]", "lineno": 95, "outcome": "failed", "keywords": ["group2", "test_get_invalid[params1]", "pytestmark", "api_call", "params1", "parametrize", "services/test_api_service.py"], "setup": {"duration": 0.0006363999999994263, "outcome": "passed"}, "metadata": {"id": "UT API.2", "description": "Testing 'get' queries return expected errors with invalid params: where clause should be nested"}, "call": {"duration": 0.00047290000000010934, "outcome": "failed", "crash": {"path": "D:\\CST Classes\\repos\\usask\\group2\\services\\test_api_service.py", "lineno": 138, "message": "AssertionError: Regex pattern 'Invalid query' does not match \"Mode is not a valid where clause. Format is ['field', 'operator', value]\"."}, "traceback": [{"path": "services\\test_api_service.py", "lineno": 138, "message": "AssertionError"}], "longrepr": "params = {'collection_name': 'History', 'limit': 0, 'meta': 'where clause should be nested', 'order_by': {}, ...}\njson_metadata = {'description': \"Testing 'get' queries return expected errors with invalid params: where clause should be nested\", 'id': 'UT API.2'}\n\n    @pytest.mark.api_call\n    @pytest.mark.parametrize(\"params\", [\n        # Invalid data but with valid types\n        ({\n            \"path\": \"Schools/\" + TEST_SCHOOL_ID + \"/UserProfiles/\" + TEST_USER_ID,\n            \"collection_name\": \"History\",\n            \"where_clauses\": None,\n            \"limit\": -1,\n            \"order_by\": {},\n            \"meta\": \"invalid limit\"\n        }),\n        ({\n            \"collection_name\": \"History\",\n            \"where_clauses\": [\"Mode\", \"==\", 0],\n            \"limit\": 0,\n            \"order_by\": {},\n            \"meta\": \"where clause should be nested\"\n        }),\n        ({\n            \"path\": \"Schools\" + TEST_SCHOOL_ID,\n            \"collection_name\": \"UserProfiles\",\n            \"where_clauses\": [[\"PrivilegeLevel\", \">\", 0], [\"DisplayName\", \"string_starts\",]],\n            \"limit\": None,\n            \"order_by\": None,\n            \"meta\": \"\"\n        })\n    ])\n    def test_get_invalid(params, json_metadata):\n        json_metadata['id'] = \"UT API.2\"\n        json_metadata['description'] = \"Testing 'get' queries return expected errors with invalid params: \" + params[\"meta\"]\n    \n        where_clauses = params[\"where_clauses\"]\n        limit = params[\"limit\"]\n        order_by = params[\"order_by\"]\n    \n        # all of them are invalid queries and should throw that exception\n        with pytest.raises(TypeError, match=\"Invalid query\"):\n            if \"path\" in params:\n                path = params[\"path\"]\n                api.get(path, where_clauses, order_by, limit)\n            else:\n                collection_name = params[\"collection_name\"]\n>               api.get_all(collection_name, where_clauses, order_by, limit)\n\nservices\\test_api_service.py:138: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <api_service.API object at 0x000001BBE3DD4080>, collection_name = 'History', where_clauses = ['Mode', '==', 0], order_by = {}, limit = 0\n\n    def get_all(self, collection_name, where_clauses, order_by=None, limit=None):\n        \"\"\" Returns data from subcollections across multiple parents.\n        Args:\n            - collection_name: name of the subcollections to look at\n            - where_clauses: list of where clauses to filter by\n                [field, operator, value]\n                operators: <, <=, ==, >, >=, array_contains, array_contains_any, in, string_starts\n                all comparisons (<, <=, >, >=, string_starts) MUST BE ON THE SAME FIELD\n            - limit: Max number of entries to return (positive integer)\n            - order_by: [{field_name: is_ascending}]\n                # is_ascending should be True for ascending, else False\n                # this also checks for the existance of a field\n                # can order by multiple fields\n                # if where clauses use <, <=, >, >= operators, must first order on same field\n                # cannot order query by fields with == or \"in\" where clause\n    \n        Usage:\n            - Many UserProfiles have child History collections.\n              Put History as collection_name to look at all History subcollections.\n            - where_clauses are required so as to not pull all the data\n            - commonly searched subcollections should have a path attribute so that\n              searches for History items within a UserProfile within a School can be\n              filtered by the school\n        \"\"\"\n        # start with the firestore client and the collection group\n        query = self._get_db().collection_group(collection_name)\n        API._last_statement += \".collection_group(\" + collection_name + \")\"\n    \n        # this stuff is the same for get and get_all: use helper function to filter\n>       query = self._filter_query(query, where_clauses, order_by, limit)\n\nservices\\api_service.py:161: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <api_service.API object at 0x000001BBE3DD4080>, query = <google.cloud.firestore_v1.query.CollectionGroup object at 0x000001BBE3F3EB00>, where_clauses = ['Mode', '==', 0], order_by = {}\nlimit = 0\n\n    def _filter_query(self, query, where_clauses=None, order_by=None, limit=None):\n        \"\"\" Helper function calls all the filter stuff on the query.\n        Does a bit of validation as well on where_clauses and order_by.\n        \"\"\"\n    \n        if where_clauses:\n            # for validating operators\n            comparisons = [\"<\", \">\", \"<=\", \">=\", \"string_starts\"]\n            all_operators = comparisons + [\"==\", \"array_contains\", \"in\", \"array_contains_any\"]\n    \n            # do some basic validation on each clause\n            for clause in where_clauses:\n                # look for wrong types and wrong length lists\n                if not isinstance(clause, list) or len(clause) != 3:\n>                   raise TypeError(str(clause) + \" is not a valid where clause. Format is ['field', 'operator', value]\")\nE                   TypeError: Mode is not a valid where clause. Format is ['field', 'operator', value]\n\nservices\\api_service.py:208: TypeError\n\nDuring handling of the above exception, another exception occurred:\n\nparams = {'collection_name': 'History', 'limit': 0, 'meta': 'where clause should be nested', 'order_by': {}, ...}\njson_metadata = {'description': \"Testing 'get' queries return expected errors with invalid params: where clause should be nested\", 'id': 'UT API.2'}\n\n    @pytest.mark.api_call\n    @pytest.mark.parametrize(\"params\", [\n        # Invalid data but with valid types\n        ({\n            \"path\": \"Schools/\" + TEST_SCHOOL_ID + \"/UserProfiles/\" + TEST_USER_ID,\n            \"collection_name\": \"History\",\n            \"where_clauses\": None,\n            \"limit\": -1,\n            \"order_by\": {},\n            \"meta\": \"invalid limit\"\n        }),\n        ({\n            \"collection_name\": \"History\",\n            \"where_clauses\": [\"Mode\", \"==\", 0],\n            \"limit\": 0,\n            \"order_by\": {},\n            \"meta\": \"where clause should be nested\"\n        }),\n        ({\n            \"path\": \"Schools\" + TEST_SCHOOL_ID,\n            \"collection_name\": \"UserProfiles\",\n            \"where_clauses\": [[\"PrivilegeLevel\", \">\", 0], [\"DisplayName\", \"string_starts\",]],\n            \"limit\": None,\n            \"order_by\": None,\n            \"meta\": \"\"\n        })\n    ])\n    def test_get_invalid(params, json_metadata):\n        json_metadata['id'] = \"UT API.2\"\n        json_metadata['description'] = \"Testing 'get' queries return expected errors with invalid params: \" + params[\"meta\"]\n    \n        where_clauses = params[\"where_clauses\"]\n        limit = params[\"limit\"]\n        order_by = params[\"order_by\"]\n    \n        # all of them are invalid queries and should throw that exception\n        with pytest.raises(TypeError, match=\"Invalid query\"):\n            if \"path\" in params:\n                path = params[\"path\"]\n                api.get(path, where_clauses, order_by, limit)\n            else:\n                collection_name = params[\"collection_name\"]\n>               api.get_all(collection_name, where_clauses, order_by, limit)\nE               AssertionError: Regex pattern 'Invalid query' does not match \"Mode is not a valid where clause. Format is ['field', 'operator', value]\".\n\nservices\\test_api_service.py:138: AssertionError"}, "teardown": {"duration": 0.000494400000000006, "outcome": "passed"}}, {"nodeid": "services/test_api_service.py::test_get_invalid[params2]", "outcome": "passed", "metadata": {"id": "UT API.2", "description": "Testing 'get' queries return expected errors with invalid params: "}}, {"nodeid": "services/test_api_service.py::test_post_valid", "outcome": "passed", "metadata": {"id": "UT API.3", "description": "Testing 'post' queries with all the datatypes available"}}, {"nodeid": "services/test_challenge_service.py::test_get_mode_count", "outcome": "passed", "metadata": {"id": "UT ChallengeService.1", "description": "Verify that the get_mode_count returns the correct data"}}, {"nodeid": "services/test_challenge_service.py::test_get_challenge_content", "outcome": "passed", "metadata": {"id": "UT ChallengeService.2", "description": "Verify that the correct attribute/data is returned"}}, {"nodeid": "services/test_challenge_service.py::test_save_challenge_results", "outcome": "passed", "metadata": {"id": "UT ChallengeService.3", "description": "Verify that data comes is saved as expected with additional fields included"}}, {"nodeid": "services/test_user_service.py::test_create_user[user0-True-A completely new user]", "outcome": "passed", "metadata": {"id": "UT UserService.1", "description": "Creating the user auth account: A completely new user"}}, {"nodeid": "services/test_user_service.py::test_create_user[user1-True-A user which already exists]", "outcome": "passed", "metadata": {"id": "UT UserService.1", "description": "Creating the user auth account: A user which already exists"}}, {"nodeid": "services/test_user_service.py::test_create_user[user2-True-Display name omitted- should still work]", "outcome": "passed", "metadata": {"id": "UT UserService.1", "description": "Creating the user auth account: Display name omitted- should still work"}}, {"nodeid": "services/test_user_service.py::test_create_user[user3-Invalid email format-invalid email- not a proper email format]", "outcome": "passed", "metadata": {"id": "UT UserService.1", "description": "Creating the user auth account: invalid email- not a proper email format"}}, {"nodeid": "services/test_user_service.py::test_create_user[user4-Password must be at least 6 characters long-invalid password- password too short]", "outcome": "passed", "metadata": {"id": "UT UserService.1", "description": "Creating the user auth account: invalid password- password too short"}}, {"nodeid": "services/test_user_service.py::test_create_user_profile[user0-Test_Post_School]", "outcome": "passed", "metadata": {"id": "UT UserService.2", "description": "Creating the user profile"}}], "warnings": [{"message": "Using 'method_whitelist' with Retry is deprecated and will be removed in v2.0. Use 'allowed_methods' instead", "category": "DeprecationWarning", "when": "collect", "filename": "d:\\cst classes\\repos\\usask\\group2\\env\\lib\\site-packages\\urllib3\\util\\retry.py", "lineno": 255}], "success": false}